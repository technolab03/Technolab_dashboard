# -*- coding: utf-8 -*-
"""Te damos la bienvenida a Colaboratory

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

# app.py â€” Dashboard SQL (Make + Forms) â€” Adaptado a tu esquema real
from __future__ import annotations
import os
from datetime import datetime, timedelta
from typing import Dict, Any, Optional

import pandas as pd
import streamlit as st
from sqlalchemy import create_engine, text
from sqlalchemy.engine import URL

# Debe ser lo primero de Streamlit
st.set_page_config(page_title="ðŸ“Š Dashboard SQL â€” Make + Forms", page_icon="ðŸ“Š", layout="wide")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  CONEXIÃ“N MYSQL  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_mysql_engine():
    if "mysql" in st.secrets:
        cfg = st.secrets["mysql"]
        host = cfg.get("host", "localhost")
        port = int(cfg.get("port", 3306))
        user = cfg.get("user")
        password = cfg.get("password")
        db = cfg.get("db")
        ssl_required = str(cfg.get("ssl", "false")).lower()
    else:
        host = os.getenv("MYSQL_HOST", "localhost")
        port = int(os.getenv("MYSQL_PORT", "3306"))
        user = os.getenv("MYSQL_USER", "root")
        password = os.getenv("MYSQL_PASSWORD", "")
        db = os.getenv("MYSQL_DB", "technolab")
        ssl_required = str(os.getenv("MYSQL_SSL", "false")).lower()

    url = URL.create(
        "mysql+pymysql", username=user, password=password,
        host=host, port=port, database=db, query={"charset": "utf8mb4"}
    )
    connect_args = {"ssl": {}} if ssl_required in ("true", "1") else {}
    eng = create_engine(url, pool_pre_ping=True, pool_recycle=1800, connect_args=connect_args)
    # Prueba de conexiÃ³n con mensaje claro
    try:
        with eng.connect() as c:
            c.execute(text("SELECT 1"))
    except Exception as e:
        st.error(f"âŒ No pude conectar a MySQL ({type(e).__name__}: {e})")
        st.stop()
    return eng

ENG = get_mysql_engine()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  QUERIES (TU ESQUEMA)  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@st.cache_data(ttl=300)
def q_clientes() -> pd.DataFrame:
    sql = """
      SELECT id, usuario_id, usuario_nombre, cliente, BIMs_instalados
      FROM clientes
      ORDER BY cliente
    """
    return pd.read_sql(text(sql), ENG)

@st.cache_data(ttl=300)
def q_biorreactores(cliente: Optional[str] = None) -> pd.DataFrame:
    where = " WHERE cliente = :c " if cliente else ""
    sql = f"""
      SELECT id, cliente, numero_bim, latitud, longitud, altura_bim, tipo_microalga, uso_luz_artificial, tipo_aireador, `fecha_instalaciÃ³n` AS fecha_instalacion
      FROM biorreactores {where}
      ORDER BY cliente, numero_bim
    """
    return pd.read_sql(text(sql), ENG, params={"c": cliente} if cliente else None)

@st.cache_data(ttl=300)
def q_registros(cliente: Optional[str], bim: Optional[int], desde: datetime, hasta: datetime) -> pd.DataFrame:
    # registros no tiene "cliente", cruzamos por biorreactores
    sql = """
      SELECT r.id, br.cliente, r.BIM AS numero_bim, r.usuario_id, r.respuestaGPT, r.HEX, r.fecha
      FROM registros r
      LEFT JOIN biorreactores br ON br.numero_bim = r.BIM
      WHERE r.fecha BETWEEN :d1 AND :d2
    """
    params: Dict[str, Any] = {"d1": desde, "d2": hasta}
    if cliente:
        sql += " AND br.cliente = :cli"
        params["cli"] = cliente
    if bim is not None:
        sql += " AND r.BIM = :bim"
        params["bim"] = bim
    sql += " ORDER BY r.fecha DESC"
    return pd.read_sql(text(sql), ENG, params=params)

@st.cache_data(ttl=300)
def q_diagnosticos(cliente: Optional[str], bim: Optional[int], desde: datetime, hasta: datetime) -> pd.DataFrame:
    # diagnosticos tampoco tiene BIM/cliente, tratamos de inferir cliente por Ãºltimo BIM del usuario_id en registros
    # Para mantenerlo simple, mostramos diagnosticos filtrados solo por fecha y, si hay cliente/BIM, intentamos coincidir por usuario_id reciente
    base = pd.read_sql(
        text("""
          SELECT d.id, d.usuario_id, d.PreguntaCliente, d.respuestaGPT, d.fecha
          FROM diagnosticos d
          WHERE d.fecha BETWEEN :d1 AND :d2
          ORDER BY d.fecha DESC
        """), ENG, params={"d1": desde, "d2": hasta}
    )
    if cliente or bim is not None:
        regs = q_registros(cliente, bim, desde - timedelta(days=90), hasta)
        if not regs.empty:
            usuarios_rel = regs["usuario_id"].dropna().unique().tolist()
            if usuarios_rel:
                base = base[base["usuario_id"].isin(usuarios_rel)]
    return base

@st.cache_data(ttl=300)
def q_fechas_bims(cliente: Optional[str], bim: Optional[int], desde: datetime, hasta: datetime) -> pd.DataFrame:
    sql = """
      SELECT fb.id, fb.numero_bim, fb.nombre_evento, fb.fecha, fb.comentarios
      FROM fechas_BIMs fb
      WHERE fb.fecha BETWEEN :d1 AND :d2
    """
    params: Dict[str, Any] = {"d1": desde, "d2": hasta}
    if bim is not None:
        sql += " AND fb.numero_bim = :b"
        params["b"] = bim
    # si filtran por cliente, reducimos por biorreactores del cliente
    if cliente:
        br = q_biorreactores(cliente)
        if br.empty:
            return pd.DataFrame(columns=["id","numero_bim","nombre_evento","fecha","comentarios"])
        bims_cliente = br["numero_bim"].astype(int).unique().tolist()
        sql += " AND fb.numero_bim IN :bims"
        # SQLAlchemy requiere tupla para IN
        params["bims"] = tuple(bims_cliente)
    sql += " ORDER BY fb.fecha DESC"
    return pd.read_sql(text(sql), ENG, params=params)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  UI: FILTROS  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.title("ðŸ“Š Dashboard SQL â€” Make + Forms")

with st.sidebar:
    st.header("Filtros")
    df_cli = q_clientes()
    cli_opts = ["(Todos)"] + df_cli["cliente"].dropna().unique().tolist()
    sel_cliente = st.selectbox("Cliente", cli_opts)
    cliente = None if sel_cliente == "(Todos)" else sel_cliente

    # BIMs por cliente desde biorreactores
    df_br = q_biorreactores(cliente)
    bims_opts = ["(Todos)"] + sorted(df_br["numero_bim"].dropna().astype(int).unique().tolist()) if not df_br.empty else ["(Todos)"]
    sel_bim = st.selectbox("NÂ° BIM", bims_opts)
    bim = None if sel_bim == "(Todos)" else int(sel_bim)

    hoy = datetime.utcnow().date()
    d1 = st.date_input("Desde", hoy - timedelta(days=30))
    d2 = st.date_input("Hasta", hoy)
    desde_dt = datetime.combine(d1, datetime.min.time())
    hasta_dt = datetime.combine(d2, datetime.max.time())

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  PANELES  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T1, T2, T3, T4, T5 = st.tabs(["Resumen", "Registros", "DiagnÃ³sticos", "Biorreactores", "Fechas BIMs"])

# ----- Resumen -----
with T1:
    regs = q_registros(cliente, bim, desde_dt, hasta_dt)
    diags = q_diagnosticos(cliente, bim, desde_dt, hasta_dt)
    fb = q_fechas_bims(cliente, bim, desde_dt, hasta_dt)

    c1, c2, c3 = st.columns(3)
    c1.metric("Registros", len(regs))
    c2.metric("DiagnÃ³sticos", len(diags))
    c3.metric("Eventos (fechas_BIMs)", len(fb))

    st.markdown("---")
    st.subheader("Ãšltimos registros")
    st.dataframe(regs.head(20), use_container_width=True)

# ----- Registros -----
with T2:
    st.subheader("Registros (Make)")
    regs = q_registros(cliente, bim, desde_dt, hasta_dt)
    if regs.empty:
        st.info("Sin registros en el rango/cliente/BIM seleccionado.")
    else:
        st.dataframe(regs, use_container_width=True)
        st.download_button("ðŸ“¥ CSV", data=regs.to_csv(index=False).encode("utf-8"), file_name="registros.csv")

# ----- DiagnÃ³sticos -----
with T3:
    st.subheader("DiagnÃ³sticos (respuestaGPT)")
    diags = q_diagnosticos(cliente, bim, desde_dt, hasta_dt)
    if diags.empty:
        st.info("Sin diagnÃ³sticos en el rango/cliente/BIM seleccionado.")
    else:
        st.dataframe(diags, use_container_width=True)
        st.download_button("ðŸ“¥ CSV", data=diags.to_csv(index=False).encode("utf-8"), file_name="diagnosticos.csv")

# ----- Biorreactores -----
with T4:
    st.subheader("Biorreactores")
    if df_br.empty:
        st.info("Sin biorreactores para este cliente.")
    else:
        # Mapa si hay coordenadas
        has_coords = df_br["latitud"].notna().any() and df_br["longitud"].notna().any()
        if has_coords:
            try:
                import pydeck as pdk
                layer = pdk.Layer(
                    "ScatterplotLayer",
                    data=df_br.rename(columns={"latitud": "lat", "longitud": "lon"}),
                    get_position='[lon, lat]',
                    get_radius=30,
                    pickable=True,
                    auto_highlight=True,
                )
                view_state = pdk.ViewState(
                    latitude=float(df_br["latitud"].astype(float).mean()),
                    longitude=float(df_br["longitud"].astype(float).mean()),
                    zoom=9,
                )
                st.pydeck_chart(pdk.Deck(layers=[layer], initial_view_state=view_state,
                                         tooltip={"text": "Cliente: {cliente}\nBIM {numero_bim}"}))
            except Exception:
                st.map(df_br.rename(columns={"latitud": "latitude", "longitud": "longitude"})[["latitude","longitude"]])
        st.dataframe(df_br, use_container_width=True)

# ----- Fechas BIMs -----
with T5:
    st.subheader("Fechas BIMs (eventos)")
    fb = q_fechas_bims(cliente, bim, desde_dt, hasta_dt)
    if fb.empty:
        st.info("Sin eventos en el rango/cliente/BIM seleccionado.")
    else:
        st.dataframe(fb, use_container_width=True)
        st.download_button("ðŸ“¥ CSV", data=fb.to_csv(index=False).encode("utf-8"), file_name="fechas_bims.csv")

st.caption("Â© Technolab â€” Dashboard SQL (Make + Forms). Ajustado a tablas: clientes, biorreactores, registros, diagnosticos, fechas_BIMs.")