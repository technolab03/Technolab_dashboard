# -*- coding: utf-8 -*-
"""Te damos la bienvenida a Colaboratory

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

# app.py â€” Dashboard SQL (Make + Forms) â€” Ajustado a relaciones por usuario_id (telÃ©fono) y sin comas
from __future__ import annotations
import os
import re
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, Iterable, Set, List

import pandas as pd
import streamlit as st
from sqlalchemy import create_engine, text
from sqlalchemy.engine import URL

# Debe ser lo primero de Streamlit
st.set_page_config(page_title="ðŸ“Š Dashboard SQL â€” Make + Forms", page_icon="ðŸ“Š", layout="wide")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  HELPERS  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def normalize_user_id(x: Any) -> Optional[str]:
    """Devuelve solo dÃ­gitos como str; si no hay dÃ­gitos, None."""
    if x is None:
        return None
    s = str(x)
    digits = re.sub(r"\D+", "", s)
    return digits if digits else None

def split_user_ids_field(value: Any) -> List[str]:
    """
    Divide un campo de usuario_id que pueda venir con varios separados por coma/espacio/;,
    y normaliza (solo dÃ­gitos).
    """
    if value is None:
        return []
    s = str(value)
    parts = re.split(r"[,\s;|]+", s)
    out = []
    for p in parts:
        n = normalize_user_id(p)
        if n:
            out.append(n)
    return out

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  CONEXIÃ“N MYSQL  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_mysql_engine():
    if "mysql" in st.secrets:
        cfg = st.secrets["mysql"]
        host = cfg.get("host", "localhost")
        port = int(cfg.get("port", 3306))
        user = cfg.get("user")
        password = cfg.get("password")
        db = cfg.get("db")
        ssl_required = str(cfg.get("ssl", "false")).lower()
    else:
        host = os.getenv("MYSQL_HOST", "localhost")
        port = int(os.getenv("MYSQL_PORT", "3306"))
        user = os.getenv("MYSQL_USER", "root")
        password = os.getenv("MYSQL_PASSWORD", "")
        db = os.getenv("MYSQL_DB", "technolab")
        ssl_required = str(os.getenv("MYSQL_SSL", "false")).lower()

    url = URL.create(
        "mysql+pymysql", username=user, password=password,
        host=host, port=port, database=db, query={"charset": "utf8mb4"}
    )
    connect_args = {"ssl": {}} if ssl_required in ("true", "1") else {}
    eng = create_engine(url, pool_pre_ping=True, pool_recycle=1800, connect_args=connect_args)
    # Test de conexiÃ³n
    with eng.connect() as c:
        c.execute(text("SELECT 1"))
    return eng

ENG = get_mysql_engine()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  QUERIES  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@st.cache_data(ttl=300)
def q_clientes() -> pd.DataFrame:
    sql = """
      SELECT id, usuario_id, usuario_nombre, cliente, BIMs_instalados
      FROM clientes
      ORDER BY cliente
    """
    df = pd.read_sql(text(sql), ENG)
    # Normalizar usuario_id para usarlo en relaciones y evitar comas
    df["usuario_id_norm"] = df["usuario_id"].apply(normalize_user_id)
    return df

@st.cache_data(ttl=300)
def q_biorreactores(cliente: Optional[str] = None) -> pd.DataFrame:
    where = " WHERE cliente = :c " if cliente else ""
    sql = f"""
      SELECT id, cliente, numero_bim, latitud, longitud, altura_bim, tipo_microalga,
             uso_luz_artificial, tipo_aireador, `fecha_instalaciÃ³n` AS fecha_instalacion
      FROM biorreactores {where}
      ORDER BY cliente, numero_bim
    """
    return pd.read_sql(text(sql), ENG, params={"c": cliente} if cliente else None)

@st.cache_data(ttl=300)
def q_registros(cliente: Optional[str], bim: Optional[int], desde: datetime, hasta: datetime) -> pd.DataFrame:
    """
    Registros: se relacionan con cliente vÃ­a biorreactores (cliente -> numero_bim -> registros.BIM).
    """
    sql = """
      SELECT r.id, br.cliente, r.BIM AS numero_bim, r.usuario_id, r.respuestaGPT, r.HEX, r.fecha
      FROM registros r
      LEFT JOIN biorreactores br ON br.numero_bim = r.BIM
      WHERE r.fecha BETWEEN :d1 AND :d2
    """
    params: Dict[str, Any] = {"d1": desde, "d2": hasta}
    if cliente:
        sql += " AND br.cliente = :cli"
        params["cli"] = cliente
    if bim is not None:
        sql += " AND r.BIM = :bim"
        params["bim"] = bim
    sql += " ORDER BY r.fecha DESC"
    df = pd.read_sql(text(sql), ENG, params=params)
    # Mostrar usuario_id como texto sin comas
    if "usuario_id" in df.columns:
        df["usuario_id"] = df["usuario_id"].apply(lambda x: normalize_user_id(x) or "")
    return df

def user_ids_from_cliente(cliente: Optional[str], rango_desde: datetime, rango_hasta: datetime) -> Set[str]:
    """
    Calcula los usuario_id asociados a un cliente:
      1) desde la tabla clientes.usuario_id (puede traer uno o varios),
      2) y desde registros del cliente (join con biorreactores).
    """
    ids: Set[str] = set()
    if not cliente:
        return ids

    # 1) Por la tabla clientes (puede haber varios en el campo)
    cli = q_clientes()
    row = cli[cli["cliente"] == cliente]
    if not row.empty:
        ids_tbl = split_user_ids_field(row.iloc[0]["usuario_id"])
        ids.update(ids_tbl)

    # 2) Por registros del cliente (en el perÃ­odo ampliado)
    regs = q_registros(cliente, None, rango_desde - timedelta(days=365), rango_hasta)
    if not regs.empty and "usuario_id" in regs.columns:
        for v in regs["usuario_id"].tolist():
            n = normalize_user_id(v)
            if n:
                ids.add(n)

    return ids

@st.cache_data(ttl=300)
def q_diagnosticos(cliente: Optional[str], bim: Optional[int], desde: datetime, hasta: datetime) -> pd.DataFrame:
    """
    DiagnÃ³sticos: se filtran por usuario_id asociado al cliente (o al BIM) y por fecha.
    """
    # Base por fecha
    base = pd.read_sql(
        text("""
          SELECT d.id, d.usuario_id, d.PreguntaCliente, d.respuestaGPT, d.fecha
          FROM diagnosticos d
          WHERE d.fecha BETWEEN :d1 AND :d2
          ORDER BY d.fecha DESC
        """),
        ENG, params={"d1": desde, "d2": hasta}
    )
    if base.empty:
        return base

    # Normalizar usuario_id para quitar comas
    base["usuario_id"] = base["usuario_id"].apply(lambda x: normalize_user_id(x) or "")

    # Si no hay filtros de cliente/BIM, devolvemos todo (ya normalizado)
    if not cliente and bim is None:
        return base

    # 1) IDs por cliente
    ids_cliente = user_ids_from_cliente(cliente, desde, hasta)

    # 2) IDs por BIM (desde registros)
    ids_bim: Set[str] = set()
    if bim is not None:
        regs_bim = q_registros(None, bim, desde - timedelta(days=365), hasta)
        if not regs_bim.empty:
            ids_bim = {normalize_user_id(v) for v in regs_bim["usuario_id"].tolist() if normalize_user_id(v)}

    # UniÃ³n de criterios
    ids_total = ids_cliente.union(ids_bim)

    if not ids_total:
        # Si no obtuvimos IDs, no hay relaciÃ³n para ese filtro
        return base.iloc[0:0]

    filtrado = base[base["usuario_id"].isin(ids_total)].reset_index(drop=True)
    return filtrado

@st.cache_data(ttl=300)
def q_fechas_bims(cliente: Optional[str], bim: Optional[int], desde: datetime, hasta: datetime) -> pd.DataFrame:
    sql = """
      SELECT fb.id, fb.numero_bim, fb.nombre_evento, fb.fecha, fb.comentarios
      FROM fechas_BIMs fb
      WHERE fb.fecha BETWEEN :d1 AND :d2
    """
    params: Dict[str, Any] = {"d1": desde, "d2": hasta}
    if bim is not None:
        sql += " AND fb.numero_bim = :b"
        params["b"] = bim
    if cliente:
        br = q_biorreactores(cliente)
        if br.empty:
            return pd.DataFrame(columns=["id","numero_bim","nombre_evento","fecha","comentarios"])
        bims_cliente = br["numero_bim"].dropna().astype(int).unique().tolist()
        if not bims_cliente:
            return pd.DataFrame(columns=["id","numero_bim","nombre_evento","fecha","comentarios"])
        sql += " AND fb.numero_bim IN :bims"
        params["bims"] = tuple(bims_cliente)
    sql += " ORDER BY fb.fecha DESC"
    return pd.read_sql(text(sql), ENG, params=params)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  UI: FILTROS  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.title("ðŸ“Š Dashboard SQL â€” Make + Forms")

with st.sidebar:
    st.header("Filtros")
    df_cli = q_clientes()
    cli_opts = ["(Todos)"] + df_cli["cliente"].dropna().unique().tolist()
    sel_cliente = st.selectbox("Cliente", cli_opts)
    cliente = None if sel_cliente == "(Todos)" else sel_cliente

    df_br = q_biorreactores(cliente)
    bims_opts = ["(Todos)"] + (sorted(df_br["numero_bim"].dropna().astype(int).unique().tolist()) if not df_br.empty else [])
    sel_bim = st.selectbox("NÂ° BIM", bims_opts)
    bim = None if sel_bim == "(Todos)" else int(sel_bim)

    hoy = datetime.utcnow().date()
    d1 = st.date_input("Desde", hoy - timedelta(days=30))
    d2 = st.date_input("Hasta", hoy)
    desde_dt = datetime.combine(d1, datetime.min.time())
    hasta_dt = datetime.combine(d2, datetime.max.time())

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  TABS  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T1, T2, T3, T4, T5 = st.tabs(["Resumen", "Registros", "DiagnÃ³sticos", "Biorreactores", "Fechas BIMs"])

# ----- Resumen -----
with T1:
    regs = q_registros(cliente, bim, desde_dt, hasta_dt)
    diags = q_diagnosticos(cliente, bim, desde_dt, hasta_dt)
    fb = q_fechas_bims(cliente, bim, desde_dt, hasta_dt)

    c1, c2, c3 = st.columns(3)
    c1.metric("Registros", len(regs))
    c2.metric("DiagnÃ³sticos", len(diags))
    c3.metric("Eventos (fechas_BIMs)", len(fb))

    st.markdown("---")
    st.subheader("Ãšltimos registros")
    st.dataframe(regs.head(20), use_container_width=True)

# ----- Registros -----
with T2:
    st.subheader("Registros (Make)")
    regs = q_registros(cliente, bim, desde_dt, hasta_dt)
    if regs.empty:
        st.info("Sin registros en el rango/cliente/BIM seleccionado.")
    else:
        # Asegurar usuario_id en texto sin comas
        if "usuario_id" in regs.columns:
            regs["usuario_id"] = regs["usuario_id"].apply(lambda x: normalize_user_id(x) or "")
        st.dataframe(regs, use_container_width=True)
        st.download_button("ðŸ“¥ CSV", data=regs.to_csv(index=False).encode("utf-8"), file_name="registros.csv")

# ----- DiagnÃ³sticos -----
with T3:
    st.subheader("DiagnÃ³sticos (respuestaGPT)")
    diags = q_diagnosticos(cliente, bim, desde_dt, hasta_dt)
    if diags.empty:
        st.info("Sin diagnÃ³sticos en el rango/cliente/BIM seleccionado.")
    else:
        # Asegurar usuario_id en texto sin comas
        if "usuario_id" in diags.columns:
            diags["usuario_id"] = diags["usuario_id"].apply(lambda x: normalize_user_id(x) or "")
        st.dataframe(diags, use_container_width=True)
        st.download_button("ðŸ“¥ CSV", data=diags.to_csv(index=False).encode("utf-8"), file_name="diagnosticos.csv")

# ----- Biorreactores -----
with T4:
    st.subheader("Biorreactores")
    if df_br.empty:
        st.info("Sin biorreactores para este cliente.")
    else:
        has_coords = df_br["latitud"].notna().any() and df_br["longitud"].notna().any()
        if has_coords:
            try:
                import pydeck as pdk
                layer = pdk.Layer(
                    "ScatterplotLayer",
                    data=df_br.rename(columns={"latitud": "lat", "longitud": "lon"}),
                    get_position='[lon, lat]',
                    get_radius=30,
                    pickable=True,
                    auto_highlight=True,
                )
                view_state = pdk.ViewState(
                    latitude=float(df_br["latitud"].astype(float).mean()),
                    longitude=float(df_br["longitud"].astype(float).mean()),
                    zoom=9,
                )
                st.pydeck_chart(pdk.Deck(layers=[layer], initial_view_state=view_state,
                                         tooltip={"text": "Cliente: {cliente}\nBIM {numero_bim}"}))
            except Exception:
                st.map(df_br.rename(columns={"latitud": "latitude", "longitud": "longitude"})[["latitude","longitude"]])
        st.dataframe(df_br, use_container_width=True)

# ----- Fechas BIMs -----
with T5:
    st.subheader("Fechas BIMs (eventos)")
    fb = q_fechas_bims(cliente, bim, desde_dt, hasta_dt)
    if fb.empty:
        st.info("Sin eventos en el rango/cliente/BIM seleccionado.")
    else:
        st.dataframe(fb, use_container_width=True)
        st.download_button("ðŸ“¥ CSV", data=fb.to_csv(index=False).encode("utf-8"), file_name="fechas_bims.csv")

st.caption("Â© Technolab â€” Dashboard SQL (Make + Forms). Filtro de Cliente por usuario_id (telÃ©fono) y sin separador de miles.")